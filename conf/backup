#!/usr/bin/env bash
# We don't stop the script on errors cause we want to backup all data we could backed up
#set -eu

#=========================================================#
#                     GLOBAL VARS                         #
#=========================================================#

# log file for mail notification
declare -r LOG_FILE=$(mktemp)
# Script name
declare -r THIS_SCRIPT="$(readlink -f "${BASH_SOURCE}")"
# Send script
declare -r SEND_SCRIPT="__INSTALL_DIR__/send"

# Global to store errors messages for mail
IS_ERROR=false
# If we force execution (without checking already script executing)
FORCE=false
# Verbose flag 1 = true, 0 = false
VERBOSE=$(sudo yunohost app setting "__APP__" debug)

# App config
IS_DEFAULT_REPO=$(yunohost app setting "__APP__" ynh_repo)

LOCAL_REPOSITORY="/home/yunohost.backup/archives"
if [[ $IS_DEFAULT_REPO == "0" ]]; then
    LOCAL_REPOSITORY=$(yunohost app setting "__APP__" local_repository)
fi
DRIVE_REPOSITORY=$(yunohost app setting "__APP__" drive_repository)
RCLONE_REPOSITORY=$(yunohost app setting "__APP__" rclone_repository)

METHOD="$(sudo yunohost app setting "__APP__" method)"
REPOSITORY=''
case "$METHOD" in
local)
    REPOSITORY="$LOCAL_REPOSITORY"
    ;;
drive | send_to_drive)
    REPOSITORY="$DRIVE_REPOSITORY"
    ;;
rclone | send_to_rclone)
    REPOSITORY="$RCLONE_REPOSITORY"
    ;;
esac

#=========================================================#
#                    SCRIPT FUNCTIONS                     #
#=========================================================#

### FUNCTION BEGIN
# Get hook scripts for backuing up conf or data app
# ARGUMENTS:
#   $1 (string) hook type. Can be : app|conf
# OUTPUTS:
# 	Print help message to stdout
### FUNCTION END
filter_hooks() {
    sudo ls /usr/share/yunohost/hooks/backup/ /etc/yunohost/hooks.d/backup/ | grep "\-$1_" | cut -d"-" -f2 | uniq 2>>"$LOG_FILE"
}

### FUNCTION BEGIN
# Usage function to show help message
# OUTPUTS:
# 	Print help message to stdout
### FUNCTION END
usage() {
    cat <<MSG_USAGE
Script used to launch Yuno-archive backup according to configuration

Usage  :
   $(basename "$0") [Options]


Options :
   -h : Show this message
   -f : Force script execution (do not check if there is another instance running)
MSG_USAGE
}

### FUNCTION BEGIN
# Ending script and send mail according to configuration
# GLOBALS:
#   ERRORS
### FUNCTION END
send_mail() {
    local mailalert="$(sudo yunohost app setting "__APP__" mailalert)"
    local msg_log="For more details, consult /var/log/__APP__/backup.log"

    if [[ $IS_ERROR && $mailalert != "never" ]]; then
        cat <(echo -e "${msg_log}\n") "$LOG_FILE" | mail -a "Content-Type: text/plain; charset=UTF-8" -s "[Yuno-archive] Backup $METHOD __APP__ failed onto $REPOSITORY" admins
    elif [[ $mailalert == "always" ]]; then
        mail -a "Content-Type: text/plain; charset=UTF-8" -s "[Yuno-archive] Backup $METHOD __APP__ succeeded onto $REPOSITORY" admins <"$LOG_FILE"
    fi

    # restore .nobackup file
    if [[ -e /home/yunohost.multimedia/.nobackup_disabled ]]; then
        sudo mv /home/yunohost.multimedia/.nobackup_disabled /home/yunohost.multimedia/.nobackup
    fi
    rm -rf "$LOG_FILE"
}

### FUNCTION BEGIN
# Add error message
# ARGUMENTS:
#   $1 (string) Error message.
# PRINT:
#   echo message on stderr
# GLOBALS:
#   ERRORS
### FUNCTION END
error() {
    local message="$1"
    echo "$message" | tee -a "$LOG_FILE"
    IS_ERROR=true
}

### FUNCTION BEGIN
# Get backup configuration and call yunohost backup hook method to backup
# all datas according to configuration
# RETURNS: 0 if OK 1 otherwise
### FUNCTION END
do_backup() {
    # system hooks methods setted with configuration
    declare -a system=()

    # Add system hooks according to configuration
    local save_system_conf
    save_system_conf=$(sudo yunohost app setting "__APP__" save_system_conf)
    if [[ "$save_system_conf" == "1" ]]; then
        echo "Conf enabled, add to backup script..." | tee -a "$LOG_FILE"

        for hook in $(filter_hooks conf); do
            system+=("$hook")
            echo "- Hook '$hook' added" | tee -a "$LOG_FILE"
        done
    fi

    # Add data hook according to configuration (without data_multimedia hook)
    local save_data
    save_data=$(sudo yunohost app setting "__APP__" save_data)
    if [[ "$save_data" == "1" ]]; then
        echo "Data enabled, add to backup script..." | tee -a "$LOG_FILE"

        for hook in $(filter_hooks data | grep -v 'data_multimedia'); do
            system+=("$hook")
            echo "- Hook '$hook' added" | tee -a "$LOG_FILE"
        done
    fi

    # Add data multimedia according to configuration
    local save_data_multimedia
    save_data_multimedia=$(sudo yunohost app setting "__APP__" save_data_multimedia)
    if [[ "$save_data_multimedia" == "1" ]]; then
        echo "Data multimedia enabled, add to backup script..." | tee -a "$LOG_FILE"
        # Disable .nobackup file if exists
        if [[ -e /home/yunohost.multimedia/.nobackup ]]; then
            sudo mv /home/yunohost.multimedia/.nobackup /home/yunohost.multimedia/.nobackup_disabled
        fi

        system+=("data_multimedia")
        echo "- Hook 'data_multimedia' added" | tee -a "$LOG_FILE"
    fi

    # Add apps according to configuration
    declare -a apps=()
    save_apps=$(sudo yunohost app setting "__APP__" save_apps | tr -d ' ')
    echo "Add apps to backup script..." | tee -a "$LOG_FILE"
    for application in $(sudo ls /etc/yunohost/apps/); do

        if ([[ "$save_apps" =~ ^exclude: ]] && grep -wq "$application" <<<"$save_apps") ||
            ([[ "$save_apps" != "all" ]] && [[ ! "$save_apps" =~ ^exclude: ]] && ! grep -wq "$application" <<<"$save_apps"); then
            continue
        fi

        if sudo test ! -f "/etc/yunohost/apps/$application/scripts/backup"; then
            echo "[WARN] The application $application has no backup script. This app won't be backed up." | tee -a "$LOG_FILE"
            continue
        fi

        apps+=("$application")
        echo "- App '$application' added'" | tee -a "$LOG_FILE"
    done

    if [[ ${#apps[@]} -eq 0 && ${#system[@]} -eq 0 ]]; then
        error "[WARN] apps and system are empty, nothing to save."
        return 0
    fi
    # Define apps option
    local option_apps=""
    if [[ ${#apps[@]} -ne 0 ]]; then
        option_apps=" --apps ${apps[*]}"
    fi

    # Define system option
    local option_system=""
    if [[ ${#system[@]} -ne 0 ]]; then
        option_system=" --system ${system[*]}"
    fi

    local current_date
    current_date=$(date +"%Y%m%d-%H%M%S")
    echo "yunohost backup create --name '${current_date}___APP__' --method '__APP___app' $option_system $option_apps" | tee -a "$LOG_FILE" 2>&1

    # We need to execute backup command in a subshell to get return code and output text (althought we have tee return which is always true)
    local backup_output=""
    local backup_ret=0
    backup_output=$(sudo yunohost backup create --name "${current_date}___APP__" --method "__APP___app" $option_system $option_apps 2>&1)
    backup_ret=$?
    # echo whithout colors to log file (for the mail)
    echo -e "$backup_output" | sed 's/\x1B\[[0-9;]\{1,\}[A-Za-z]//g' >> "$LOG_FILE"
    echo -e "$backup_output"

    if [[ $backup_ret -eq 1 ]]; then
        error "[ERROR] Cannot backup archive to $METHOD '$REPOSITORY'"
    fi
    return $backup_ret
}

### FUNCTION BEGIN
# Call send script to execute send method according to configuration
# RETURNS: 0 if OK 1 otherwise
### FUNCTION END
do_send() {
    echo "$SEND_SCRIPT" | tee -a "$LOG_FILE" 2>&1

    # We need to execute backup command in a subshell to get return code and output text (althought we have tee return which is always true)
    local backup_output=""
    local backup_ret=0
    backup_output=$(sudo $SEND_SCRIPT 2>&1)
    backup_ret=$?
    # echo whithout colors to log file (for the mail)
    echo -e "$backup_output" | sed 's/\x1B\[[0-9;]\{1,\}[A-Za-z]//g' >> "$LOG_FILE"
    echo -e "$backup_output"

    if [[ $backup_ret -eq 1 ]]; then
        error "[ERROR] Cannot send archives to '$REPOSITORY'"
    fi
    return $backup_ret
}


### FUNCTION BEGIN
# Check if the app is updating or if there is another backup process running
# PRINT:
#   echo message on stderr
# RETURNS:
#   0 of the app is not updating and no other backup process is running
#   1 if the app is updating or another backup process is running
### FUNCTION END
is_updating_or_running() {

    local state
    state=$(sudo yunohost app setting "__APP__" state)

    if [[ $state == "ongoing" || $state == "updating" ]]; then
        return 1
    fi

    if [[ "$status" =~ ^updated\ at\ [0-9]{4}-[0-9]{2}-[0-9]{2}\ [0-9]{2}:[0-9]{2}:[0-9]{2}$ ]]; then
        # Extract timestamp from status
        timestamp=$(echo "$status" | awk '{print $3, $4}')
        # Convert timestamp to epoch
        timestamp_epoch=$(date -d "$timestamp" +%s)
        # Get current date in epoch
        now_epoch=$(date +%s)
        # Calculate difference
        diff=$((now_epoch - timestamp_epoch))

        if [[ $diff -lt 300 ]]; then
            error "The app was updated less than 5 minutes ago, this is an unvoluntary backup."
            return 1
        fi
    fi



    status="updated at 2025-07-31 14:30:00"

    return 0
}

#=========================================================#
#                           MAIN                          #
#=========================================================#
while getopts "fh" option; do
    case "${option}" in
    h)
        usage
        exit 0
        ;;
    f)
        FORCE=true
        ;;
    *)
        usage
        exit 1
        ;;
    esac
done

# This is a hack to avoid executing script during ar backup or just after it.
# For an obscure reason, the script is executed by systemd just after an update
# We use FORCE to by pass this check
if [[ ! $FORCE ]]; then
    if is_updating_or_running; then
        error "[ERROR] There is another backup process running or app in updating state. Abord.\nIf the problem persist after reboot, call '$THIS_SCRIPT' with -f option"
        send_mail
        exit 1
    fi
fi


now="$(date "+%Y-%m-%d %H:%M:%S")"
echo "${now} STARTING BACKUP __APP__" | tee -a "$LOG_FILE"


case "$METHOD" in
send_to_drive | send_to_rclone)
    do_send
    ;;
*)
    do_backup
    ;;
esac

now="$(date "+%Y-%m-%d %H:%M:%S")"
echo "${now} END BACKUP __APP__" | tee -a "$LOG_FILE"

send_mail
